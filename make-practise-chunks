#!/usr/bin/sh

if [ ! $1 ]; then
  echo "
Usage:

$(basename $0) file

file.mp3 is the source file in the current directory
file.txt contains a list of timestamps where the audio should be split

the first line in the audio is the start of the first chunk
timestamps are in seconds, like the labels files exported from audacity
practise files include the previous chunk, so include an intro chunk
the last line of the timestamp file is the end of the last chunk
start a new voice with a numeric-only label
"
  exit 1
fi

# set up the environment
calc() { echo "$*" | bc -l ; } # no floating point arithmetic in posix
silence=3; padding=2; format=mp3; count=1
name=$1; input=$name.$format;
timestamps=3; exec 3< $name.txt

#
# cut a single chunk at the given tempo from the input file
#
# current timestamp
# next timestamp
# tempo
# output file
#
cut_chunk() {
  ffmpeg -nostdin -loglevel error \
         -ss $(calc $1-$padding) -to $(calc $2+$padding) \
         -i $input -f $format -ac 1 -ar 48000 -q 4 \
         -af afade=d=$padding,afade=t=out:st=$(calc $2-$1+$padding):d=$padding,atempo=$3,adelay=${silence}s:all=true \
         "$4"
}

# process timestamps
read current x label <& $timestamps
while read next x nextlabel; do
  if expr match "$label" "^[0-9]\+$" > /dev/null; then
    voice=$label
    count=1
  elif expr match "$label" "^[^X]" > /dev/null; then

    # one folder per chunk
    outputdir=000.$name/000.$voice$(printf %02d $count).$label
    mkdir -p "$outputdir"

    # cut and retempo each chunk
    cut_chunk $current $next 0.50 "$outputdir/050.mp3"
    cut_chunk $current $next 0.75 "$outputdir/075.mp3"
    cut_chunk $current $next 1.00 "$outputdir/100.mp3"
    cut_chunk $current $next 1.25 "$outputdir/125.mp3"
    cut_chunk $current $next 1.50 "$outputdir/150.mp3"

    count=$((count + 1))
    echo "wrote $outputdir"
  fi
  prev=$current; current=$next; label=$nextlabel;
done <& $timestamps

